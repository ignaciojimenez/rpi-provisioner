#!/bin/bash
#
# Raspberry Pi Provisioner
# Flash and configure Raspberry Pi SD cards with a single command
#
# Features: Image caching, SSH key installation, WiFi setup, host presets
# Platform: macOS and Linux

set -e
set -u
set -o pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CACHE_DIR="${SCRIPT_DIR}/cache"
CONFIG_FILE="${SCRIPT_DIR}/hosts.yml"
TEMP_DIR="/tmp/raspberrypi_provision_$$"
LOG_FILE="/tmp/provision_pi_$(date +%Y%m%d_%H%M%S).log"

# Logging (defined early so other init code can use it)
log_info() { echo -e "${BLUE}[INFO]${NC} $*" | tee -a "$LOG_FILE" >&2; }
log_success() { echo -e "${GREEN}[✓]${NC} $*" | tee -a "$LOG_FILE" >&2; }
log_warning() { echo -e "${YELLOW}[!]${NC} $*" | tee -a "$LOG_FILE" >&2; }
log_error() { echo -e "${RED}[✗]${NC} $*" | tee -a "$LOG_FILE" >&2; }

# Detect OS
OS_TYPE="$(uname -s)"
case "${OS_TYPE}" in
    Darwin*) OS="macos";;
    Linux*)  OS="linux";;
    *) log_error "Unsupported OS: ${OS_TYPE}"; exit 1;;
esac

# Cleanup function
cleanup() {
    log_info "Cleaning up..."
    [[ -d "$TEMP_DIR" ]] && rm -rf "$TEMP_DIR"
    log_success "Cleanup complete"
}

trap cleanup EXIT

# Usage function
usage() {
    cat << EOF
Usage: $(basename "$0") <image_source> <hostname> [options]

Image Sources:
  raspbian       Latest Raspberry Pi OS Lite (64-bit)
  raspbian32     Latest Raspberry Pi OS Lite (32-bit)
  raspbian-full  Latest Raspberry Pi OS Full
  <url>          Direct URL to an image file

Hostnames:
  Use any custom hostname, or use a predefined preset from hosts.yml
  See hosts.yml for preset configurations and to add your own

Options:
  --wifi-ssid <ssid>      WiFi network name
  --wifi-pass <password>  WiFi password
  --user <username>       Primary user (default: pi)
  --password <pass>       Initial user password (default: raspberry)
  --ssh-key <path>        Path to SSH public key
  --github <username>     Fetch SSH keys from GitHub
  --locale <locale>       System locale (default: en_US.UTF-8)
  --timezone <tz>         System timezone (default: UTC)
  --no-wifi               Disable WiFi and Bluetooth
  --skip-flash            Skip flashing, only configure

Examples:
  $(basename "$0") raspbian mypi --github yourusername
  $(basename "$0") raspbian32 mypi --no-wifi
  $(basename "$0") raspbian mypi --wifi-ssid "MyNetwork" --wifi-pass "MyPassword"

EOF
    exit 0
}

# Load host preset from config file
load_host_preset() {
    local hostname="$1"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warning "Config file not found: $CONFIG_FILE"
        return 1
    fi
    
    # Simple YAML parser for our config structure
    # Extract preset section for the given hostname
    local in_preset=false
    local preset_content=""
    
    while IFS= read -r line; do
        # Check if we're entering the target preset
        if [[ "$line" =~ ^[[:space:]]*${hostname}:[[:space:]]*$ ]]; then
            in_preset=true
            continue
        fi
        
        # Check if we've left the preset (new preset or section starts)
        if [[ "$in_preset" == true ]] && [[ "$line" =~ ^[[:space:]]{2}[a-zA-Z_] ]]; then
            # Check if it's a new preset (same indentation level)
            if [[ "$line" =~ ^[[:space:]]{2}[a-zA-Z_]+: ]]; then
                break
            fi
        fi
        
        # Capture preset content
        if [[ "$in_preset" == true ]]; then
            preset_content+="$line"$'\n'
        fi
    done < "$CONFIG_FILE"
    
    if [[ -z "$preset_content" ]]; then
        return 1  # Preset not found
    fi
    
    echo "$preset_content"
}

# Parse config value from preset content
get_config_value() {
    local preset_content="$1"
    local key="$2"
    
    # Extract value after "key: " removing quotes if present
    # Use || true to prevent grep from causing script exit when key not found
    echo "$preset_content" | grep -E "^[[:space:]]+${key}:" | sed -E 's/^[[:space:]]+[^:]+:[[:space:]]*//; s/^["'\'']//; s/["'\'']$//' | head -1 || true
}

# Extract hardware configuration from preset
# Returns the config content if hardware section exists
get_hardware_config() {
    local preset_content="$1"
    
    # Look for hardware section and extract the config block
    # This handles the YAML structure with "config: |" followed by indented lines
    echo "$preset_content" | awk '
        /^[[:space:]]+hardware:/ { in_hw=1; next }
        in_hw && /^[[:space:]]+config:[[:space:]]*\|/ { in_config=1; next }
        in_config && /^[[:space:]]{10,}/ { print; next }
        in_config && /^[[:space:]]{0,9}[a-z]/ { exit }
    ' || true
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    # Common dependencies
    for cmd in curl dd openssl wpa_passphrase; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done
    
    # OS-specific dependencies
    if [[ "$OS" == "macos" ]]; then
        if ! command -v diskutil &>/dev/null; then
            missing+=("diskutil")
        fi
    else
        # Linux
        if ! command -v lsblk &>/dev/null; then
            missing+=("lsblk")
        fi
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        log_info "wpa_passphrase is typically in 'wpa_supplicant' or 'wpasupplicant' package"
        exit 1
    fi
    
    log_success "All dependencies satisfied"
}

# Check cache for image file
check_cache() {
    local filename="$1"
    mkdir -p "$CACHE_DIR"
    
    if [[ -f "$CACHE_DIR/$filename" ]]; then
        log_success "Found in cache: $filename"
        return 0
    fi
    return 1
}

# Save to cache
save_to_cache() {
    local source_file="$1"
    local filename=$(basename "$source_file")
    mkdir -p "$CACHE_DIR"
    
    log_info "Saving to cache: $filename"
    cp "$source_file" "$CACHE_DIR/$filename"
}

# Download image
download_image() {
    local source="$1"
    local dest_file=""
    
    mkdir -p "$TEMP_DIR"
    mkdir -p "$CACHE_DIR"
    
    # Set user agent for curl requests
    local agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    
    case "$source" in
        raspbian|raspbian64)
            log_info "Fetching latest Raspberry Pi OS Lite (64-bit)..."
            local base_url="https://downloads.raspberrypi.com/raspios_lite_arm64/images/"
            
            # Step 1: Get the latest version directory
            log_info "Finding latest version directory..."
            local latest_dir=$(curl -s -L -A "${agent}" "${base_url}" | \
                grep -o 'href="raspios_lite_arm64-[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/"' | \
                cut -d'"' -f2 | sort -r | head -1)
            
            if [[ -z "$latest_dir" ]]; then
                log_error "Failed to find latest version directory"
                exit 1
            fi
            
            log_info "Found latest directory: $latest_dir"
            
            # Step 2: Get the actual image filename from that directory
            local latest_url="${base_url}${latest_dir}"
            local image_file=$(curl -s -L -A "${agent}" "${latest_url}" | \
                grep -o 'href="[^"]*\.img\.xz"' | \
                grep -v 'torrent\|sha\|sig' | \
                head -1 | cut -d'"' -f2)
            
            if [[ -z "$image_file" ]]; then
                log_error "Failed to find image file in directory"
                exit 1
            fi
            
            log_info "Found image file: $image_file"
            
            # Step 3: Check cache or download the image
            dest_file="$TEMP_DIR/${image_file}"
            if check_cache "${image_file}"; then
                cp "$CACHE_DIR/${image_file}" "$dest_file"
            else
                local download_url="${latest_url}${image_file}"
                log_info "Downloading from: $download_url"
                curl -L -o "$dest_file" "$download_url"
                save_to_cache "$dest_file"
            fi
            ;;
        raspbian32)
            log_info "Fetching latest Raspberry Pi OS Lite (32-bit)..."
            local base_url="https://downloads.raspberrypi.com/raspios_lite_armhf/images/"
            
            # Step 1: Get the latest version directory
            log_info "Finding latest version directory..."
            local latest_dir=$(curl -s -L -A "${agent}" "${base_url}" | \
                grep -o 'href="raspios_lite_armhf-[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/"' | \
                cut -d'"' -f2 | sort -r | head -1)
            
            if [[ -z "$latest_dir" ]]; then
                log_error "Failed to find latest version directory"
                exit 1
            fi
            
            log_info "Found latest directory: $latest_dir"
            
            # Step 2: Get the actual image filename from that directory
            local latest_url="${base_url}${latest_dir}"
            local image_file=$(curl -s -L -A "${agent}" "${latest_url}" | \
                grep -o 'href="[^"]*\.img\.xz"' | \
                grep -v 'torrent\|sha\|sig' | \
                head -1 | cut -d'"' -f2)
            
            if [[ -z "$image_file" ]]; then
                log_error "Failed to find image file in directory"
                exit 1
            fi
            
            log_info "Found image file: $image_file"
            
            # Step 3: Check cache or download the image
            dest_file="$TEMP_DIR/${image_file}"
            if check_cache "${image_file}"; then
                cp "$CACHE_DIR/${image_file}" "$dest_file"
            else
                local download_url="${latest_url}${image_file}"
                log_info "Downloading from: $download_url"
                curl -L -o "$dest_file" "$download_url"
                save_to_cache "$dest_file"
            fi
            ;;
        raspbian-full)
            log_info "Fetching latest Raspberry Pi OS Full..."
            local base_url="https://downloads.raspberrypi.com/raspios_full_arm64/images/"
            
            # Step 1: Get the latest version directory
            log_info "Finding latest version directory..."
            local latest_dir=$(curl -s -L -A "${agent}" "${base_url}" | \
                grep -o 'href="raspios_full_arm64-[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/"' | \
                cut -d'"' -f2 | sort -r | head -1)
            
            if [[ -z "$latest_dir" ]]; then
                log_error "Failed to find latest version directory"
                exit 1
            fi
            
            log_info "Found latest directory: $latest_dir"
            
            # Step 2: Get the actual image filename from that directory
            local latest_url="${base_url}${latest_dir}"
            local image_file=$(curl -s -L -A "${agent}" "${latest_url}" | \
                grep -o 'href="[^"]*\.img\.xz"' | \
                grep -v 'torrent\|sha\|sig' | \
                head -1 | cut -d'"' -f2)
            
            if [[ -z "$image_file" ]]; then
                log_error "Failed to find image file in directory"
                exit 1
            fi
            
            log_info "Found image file: $image_file"
            
            # Step 3: Check cache or download the image
            dest_file="$TEMP_DIR/${image_file}"
            if check_cache "${image_file}"; then
                cp "$CACHE_DIR/${image_file}" "$dest_file"
            else
                local download_url="${latest_url}${image_file}"
                log_info "Downloading from: $download_url"
                curl -L -o "$dest_file" "$download_url"
                save_to_cache "$dest_file"
            fi
            ;;
        http*|ftp*)
            log_info "Downloading image from URL..."
            local image_file=$(basename "$source")
            dest_file="$TEMP_DIR/${image_file}"
            if check_cache "${image_file}"; then
                cp "$CACHE_DIR/${image_file}" "$dest_file"
            else
                curl -L -o "$dest_file" "$source"
                save_to_cache "$dest_file"
            fi
            ;;
        *)
            log_error "Unknown image source: $source"
            exit 1
            ;;
    esac
    
    # Verify the file was downloaded
    if [[ ! -f "$dest_file" ]]; then
        log_error "Download failed - file does not exist: $dest_file"
        exit 1
    fi
    
    local file_size=$(stat -f %z "$dest_file" 2>/dev/null || stat -c %s "$dest_file" 2>/dev/null)
    if [[ "$file_size" -lt 1000000 ]]; then
        log_error "Downloaded file is too small (${file_size} bytes), likely an error page"
        log_info "File contents:"
        head -20 "$dest_file" | tee -a "$LOG_FILE"
        exit 1
    fi
    
    # Extract if compressed
    if [[ "$dest_file" == *.xz ]]; then
        log_info "Extracting image..."
        unxz "$dest_file"
        dest_file="${dest_file%.xz}"
    elif [[ "$dest_file" == *.zip ]]; then
        log_info "Extracting image..."
        unzip -o "$dest_file" -d "$TEMP_DIR"
        dest_file=$(find "$TEMP_DIR" -name "*.img" | head -1)
    fi
    
    log_success "Image ready: $dest_file"
    echo "$dest_file"
}

# Find SD card
# Args: $1 = skip_confirmation (optional, default: false)
find_sd_card() {
    local skip_confirmation="${1:-false}"
    log_info "Looking for SD card..."
    
    # Find external disks (SD cards typically show as external)
    local disks=$(diskutil list | grep external | cut -d" " -f1)
    local number_of_disks=$(echo "$disks" | grep -v "^$" | wc -l | xargs)
    local sd_card=""
    
    log_info "Found $number_of_disks external disk(s)"
    
    if [[ $number_of_disks -eq 0 ]]; then
        log_error "No external disks found. Please insert SD card and try again."
        exit 1
    elif [[ $number_of_disks -eq 1 ]]; then
        sd_card="$disks"
        log_info "Found one external disk: $sd_card"
    else
        # Multiple disks found - let user choose
        log_info "Multiple external disks found:"
        local i=1
        local disk_array=()
        while IFS= read -r disk_line; do
            [[ -z "$disk_line" ]] && continue
            disk_array+=("$disk_line")
            local disk_name=$(diskutil info "$disk_line" | grep "Device / Media Name" | cut -d":" -f2 | xargs)
            local disk_size=$(diskutil info "$disk_line" | grep "Disk Size" | cut -d":" -f2 | xargs)
            echo "  [$i] $disk_line - $disk_name ($disk_size)" | tee -a "$LOG_FILE" >&2
            i=$((i+1))
        done <<< "$disks"
        
        echo -n "Select disk number [1-${#disk_array[@]}]: " >&2
        read -r selection
        
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le ${#disk_array[@]} ]]; then
            sd_card="${disk_array[$((selection-1))]}"
        else
            log_error "Invalid selection"
            exit 1
        fi
    fi
    
    # Display selected disk information
    log_info "Selected disk: $sd_card"
    diskutil info "$sd_card" | grep -E "Device Node|Device / Media Name|Disk Size|Total Size" | tee -a "$LOG_FILE" >&2
    
    # Confirm with user (only if not skipping confirmation)
    if [[ "$skip_confirmation" != "true" ]]; then
        echo >&2
        log_warning "This will ERASE ALL DATA on $sd_card"
        echo -n "Are you sure you want to proceed? [y/N]: " >&2
        read -r confirm
        if [[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]]; then
            log_error "Aborted by user"
            exit 1
        fi
        log_success "SD card confirmed: $sd_card"
    else
        log_info "Using SD card: $sd_card"
    fi
    
    echo "$sd_card"
}

# Flash SD card
flash_sd_card() {
    local img_file="$1"
    local sd_card="$2"
    
    log_info "Unmounting SD card..."
    diskutil unmountDisk "$sd_card"
    
    # Get raw device name
    local raw_disk="${sd_card/disk/rdisk}"
    
    log_info "Flashing image to $sd_card (this may take several minutes)..."
    log_info "Image: $img_file"
    
    # Flash with progress
    local img_size=$(stat -f %z "$img_file")
    
    sudo dd if="$img_file" of="$raw_disk" bs=4M status=progress 2>&1 | while read -r line; do
        if [[ "$line" == *"bytes"* ]]; then
            echo -ne "\r$line"
        fi
    done
    
    echo
    log_success "Image flashed successfully"
    
    # Wait for disk to be ready
    sleep 5
    diskutil mountDisk "$sd_card"
    sleep 2
}

# ==============================================================================
# CONFIGURATION PARSING
# ==============================================================================

# Parse all configuration sources: defaults, presets, and CLI options
# Returns variables via stdout in "key=value" format
parse_provisioning_options() {
    local hostname="$1"
    shift
    
    # Load defaults from config file (lowest priority)
    local default_user=""
    local default_timezone=""
    local default_locale=""
    local default_keymap=""
    local default_disable_wifi=""
    local default_wifi_ssid=""
    local default_wifi_pass=""
    local default_github=""
    
    if [[ -n "${DEFAULTS_CONTENT:-}" ]]; then
        default_user=$(get_config_value "$DEFAULTS_CONTENT" "user")
        default_timezone=$(get_config_value "$DEFAULTS_CONTENT" "timezone")
        default_locale=$(get_config_value "$DEFAULTS_CONTENT" "locale")
        default_keymap=$(get_config_value "$DEFAULTS_CONTENT" "keymap")
        default_disable_wifi=$(get_config_value "$DEFAULTS_CONTENT" "disable_wifi")
        default_wifi_ssid=$(get_config_value "$DEFAULTS_CONTENT" "wifi_ssid")
        default_wifi_pass=$(get_config_value "$DEFAULTS_CONTENT" "wifi_pass")
        default_github=$(get_config_value "$DEFAULTS_CONTENT" "github")
    fi
    
    # Load preset values (override defaults)
    local preset_user=""
    local preset_timezone=""
    local preset_locale=""
    local preset_keymap=""
    local preset_disable_wifi=""
    
    if [[ -n "${PRESET_CONTENT:-}" ]]; then
        preset_user=$(get_config_value "$PRESET_CONTENT" "user")
        preset_timezone=$(get_config_value "$PRESET_CONTENT" "timezone")
        preset_locale=$(get_config_value "$PRESET_CONTENT" "locale")
        preset_keymap=$(get_config_value "$PRESET_CONTENT" "keymap")
        preset_disable_wifi=$(get_config_value "$PRESET_CONTENT" "disable_wifi")
    fi
    
    # Start with defaults, then apply presets, then will apply CLI options
    local wifi_ssid="${default_wifi_ssid:-}"
    local wifi_pass="${default_wifi_pass:-}"
    local user="${preset_user:-${default_user:-pi}}"
    local bootstrap_password="raspberry"
    local ssh_key=""
    local github_user="${default_github:-}"
    local locale="${preset_locale:-${default_locale:-en_US.UTF-8}}"
    local timezone="${preset_timezone:-${default_timezone:-UTC}}"
    local keymap="${preset_keymap:-${default_keymap:-us}}"
    local disable_wifi="${preset_disable_wifi:-${default_disable_wifi:-false}}"
    
    # Parse CLI options (highest priority - overrides everything)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --wifi-ssid) wifi_ssid="$2"; shift 2 ;;
            --wifi-pass) wifi_pass="$2"; shift 2 ;;
            --user) user="$2"; shift 2 ;;
            --password) bootstrap_password="$2"; shift 2 ;;
            --ssh-key) ssh_key="$2"; shift 2 ;;
            --github) github_user="$2"; shift 2 ;;
            --locale) locale="$2"; shift 2 ;;
            --timezone) timezone="$2"; shift 2 ;;
            --no-wifi) disable_wifi=true; shift ;;
            *) shift ;;
        esac
    done
    
    # Export for use by other functions
    echo "user=$user"
    echo "bootstrap_password=$bootstrap_password"
    echo "ssh_key=$ssh_key"
    echo "github_user=$github_user"
    echo "locale=$locale"
    echo "timezone=$timezone"
    echo "keymap=$keymap"
    echo "wifi_ssid=$wifi_ssid"
    echo "wifi_pass=$wifi_pass"
    echo "disable_wifi=$disable_wifi"
}

# Find and validate boot partition
find_boot_partition() {
    local boot_volume="/Volumes/boot"
    [[ ! -d "$boot_volume" ]] && boot_volume="/Volumes/bootfs"
    
    if [[ ! -d "$boot_volume" ]]; then
        log_error "Boot partition not found. Please ensure SD card is mounted."
        exit 1
    fi
    
    echo "$boot_volume"
}

# Retrieve SSH keys from various sources
get_ssh_keys() {
    local github_user="$1"
    local ssh_key_file="$2"
    
    if [[ -n "$github_user" ]]; then
        log_info "Fetching SSH keys from GitHub: $github_user"
        local keys=$(curl -sf "https://github.com/${github_user}.keys" || echo "")
        if [[ -z "$keys" ]]; then
            log_warning "Failed to fetch GitHub keys, will use password auth"
        else
            log_success "GitHub SSH keys retrieved"
            echo "$keys"
            return 0
        fi
    elif [[ -n "$ssh_key_file" && -f "$ssh_key_file" ]]; then
        log_info "Using SSH key from: $ssh_key_file"
        cat "$ssh_key_file"
        return 0
    elif [[ -f "$HOME/.ssh/id_rsa.pub" ]]; then
        log_info "Using default SSH key: ~/.ssh/id_rsa.pub"
        cat "$HOME/.ssh/id_rsa.pub"
        return 0
    elif [[ -f "$HOME/.ssh/id_ed25519.pub" ]]; then
        log_info "Using default SSH key: ~/.ssh/id_ed25519.pub"
        cat "$HOME/.ssh/id_ed25519.pub"
        return 0
    fi
    
    echo ""
}

# Apply headless optimizations to config.txt
# These settings reduce resource usage for systems without displays
apply_headless_optimizations() {
    local boot_volume="$1"
    local is_headless="$2"  # true/false
    
    # Only apply for headless (lite) images
    if [[ "$is_headless" != "true" ]]; then
        return
    fi
    
    log_info "Applying headless optimizations..."
    cat >> "$boot_volume/config.txt" << 'EOF'

# Headless optimizations
# Reduce GPU memory to minimum (16MB) - headless systems don't need GPU
gpu_mem=16

# Disable rainbow splash screen on boot
disable_splash=1

# Faster boot - no delay waiting for display
boot_delay=0

# Disable HDMI on boot (saves ~25mA power)
# If you need to connect a display later, comment this out
hdmi_blanking=2

# Disable audio (unless hardware config enables it)
dtparam=audio=off
EOF
    log_success "Headless optimizations applied"
}

# Prepare WiFi configuration block for firstrun.sh
prepare_wifi_config() {
    local wifi_ssid="$1"
    local wifi_pass="$2"
    
    if [[ -z "$wifi_ssid" ]] || [[ -z "$wifi_pass" ]]; then
        echo ""
        return
    fi
    
    log_info "Preparing WiFi configuration..."
    
    # Hash the WiFi password for security
    local wifi_psk_hash=$(wpa_passphrase "$wifi_ssid" "$wifi_pass" 2>/dev/null | grep -v '#psk' | grep 'psk=' | cut -d'=' -f2)
    if [[ -z "$wifi_psk_hash" ]]; then
        log_warning "Could not hash WiFi password, using plaintext"
        wifi_psk_hash="\"$wifi_pass\""
    fi
    
    local wifi_block="# Configure WiFi\n"
    wifi_block+="if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then\n"
    wifi_block+="   /usr/lib/raspberrypi-sys-mods/imager_custom set_wlan '$wifi_ssid' '$wifi_psk_hash' 'US'\n"
    wifi_block+="else\n"
    wifi_block+="cat >/etc/wpa_supplicant/wpa_supplicant.conf <<'WPAEOF'\n"
    wifi_block+="country=US\n"
    wifi_block+="ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n"
    wifi_block+="ap_scan=1\n"
    wifi_block+="update_config=1\n"
    wifi_block+="network={\n"
    wifi_block+="\\tssid=\"$wifi_ssid\"\n"
    wifi_block+="\\tpsk=$wifi_psk_hash\n"
    wifi_block+="}\n"
    wifi_block+="WPAEOF\n"
    wifi_block+="   chmod 600 /etc/wpa_supplicant/wpa_supplicant.conf\n"
    wifi_block+="   rfkill unblock wifi\n"
    wifi_block+="   for filename in /var/lib/systemd/rfkill/*:wlan ; do\n"
    wifi_block+="       echo 0 > "'$'"filename\n"
    wifi_block+="   done\n"
    wifi_block+="fi"
    
    log_success "WiFi configuration prepared"
    echo -e "$wifi_block"
}

# ==============================================================================
# BOOT CONFIGURATION
# ==============================================================================

# Main boot configuration function - orchestrates all boot setup
configure_boot() {
    local sd_card="$1"
    local hostname="$2"
    local image_source="$3"
    shift 3
    
    # Parse all configuration options
    local config_output=$(parse_provisioning_options "$hostname" "$@")
    eval "$config_output"
    
    # Find and validate boot partition
    local boot_volume=$(find_boot_partition)
    log_info "Configuring boot partition at $boot_volume"
    
    # Generate encrypted password
    log_info "Configuring user: $user"
    local encrypted_pass=$(openssl passwd -6 "$bootstrap_password")
    log_success "Password encrypted"
    
    # Get SSH keys
    local ssh_keys=$(get_ssh_keys "$github_user" "$ssh_key")
    [[ -z "$ssh_keys" ]] && log_warning "No SSH keys found, will use password auth"
    
    # Prepare WiFi configuration
    local wifi_block=$(prepare_wifi_config "$wifi_ssid" "$wifi_pass")
    
    # Apply hardware configurations to config.txt
    if [[ "$disable_wifi" == "true" ]]; then
        log_info "Disabling WiFi and Bluetooth..."
        cat >> "$boot_volume/config.txt" << EOF

# Disable WiFi and Bluetooth
dtoverlay=disable-wifi
dtoverlay=disable-bt
EOF
        log_success "WiFi and Bluetooth disabled"
    fi
    
    if [[ -n "${PRESET_CONTENT:-}" ]]; then
        local hardware_config=$(get_hardware_config "$PRESET_CONTENT")
        if [[ -n "$hardware_config" ]]; then
            log_info "Applying hardware configuration from preset"
            cat >> "$boot_volume/config.txt" << EOF

# Hardware configuration from preset
$hardware_config
EOF
            log_success "Hardware configuration applied"
        fi
    fi
    
    # Apply headless optimizations for lite images
    # Detect if this is a headless image based on image source
    local is_headless="false"
    case "$image_source" in
        raspbian|raspbian32)
            is_headless="true"
            ;;
        raspbian-full)
            is_headless="false"
            ;;
        *)
            # For custom URLs, check filename for "lite" or "headless"
            if [[ "$image_source" =~ (lite|headless) ]]; then
                is_headless="true"
            fi
            ;;
    esac
    apply_headless_optimizations "$boot_volume" "$is_headless"
    
    # Create first-boot script (following rpi-imager pattern)
    log_info "Creating firstrun.sh"
    cat > "$boot_volume/firstrun.sh" << 'FIRSTRUN_EOF'
#!/bin/bash
set +e

CURRENT_HOSTNAME=$(cat /etc/hostname | tr -d " \t\n\r")
if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then
   /usr/lib/raspberrypi-sys-mods/imager_custom set_hostname "__HOSTNAME__"
else
   echo "__HOSTNAME__" >/etc/hostname
   sed -i "s/127.0.1.1.*$CURRENT_HOSTNAME/127.0.1.1\t__HOSTNAME__/g" /etc/hosts
fi

FIRSTUSER=`getent passwd 1000 | cut -d: -f1`
FIRSTUSERHOME=`getent passwd 1000 | cut -d: -f6`

# Configure user and password
if [ -f /usr/lib/userconf-pi/userconf ]; then
   /usr/lib/userconf-pi/userconf '__USER__' '__ENCRYPTED_PASS__'
else
   echo "$FIRSTUSER:"'__ENCRYPTED_PASS__' | chpasswd -e
   if [ "$FIRSTUSER" != "__USER__" ]; then
      usermod -l "__USER__" "$FIRSTUSER"
      usermod -m -d "/home/__USER__" "__USER__"
      groupmod -n "__USER__" "$FIRSTUSER"
      if grep -q "^autologin-user=" /etc/lightdm/lightdm.conf ; then
         sed /etc/lightdm/lightdm.conf -i -e "s/^autologin-user=.*/autologin-user=__USER__/"
      fi
      if [ -f /etc/systemd/system/getty@tty1.service.d/autologin.conf ]; then
         sed /etc/systemd/system/getty@tty1.service.d/autologin.conf -i -e "s/$FIRSTUSER/__USER__/"
      fi
      if [ -f /etc/sudoers.d/010_pi-nopasswd ]; then
         sed -i "s/^$FIRSTUSER /__USER__ /" /etc/sudoers.d/010_pi-nopasswd
      fi
   fi
fi

__SSH_KEYS_BLOCK__

# Set timezone
if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then
   /usr/lib/raspberrypi-sys-mods/imager_custom set_timezone '__TIMEZONE__'
else
   rm -f /etc/localtime
   echo "__TIMEZONE__" >/etc/timezone
   dpkg-reconfigure -f noninteractive tzdata
fi

# Set locale
if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then
   /usr/lib/raspberrypi-sys-mods/imager_custom set_locale '__LOCALE__'
else
   sed -i 's/^# *__LOCALE__ UTF-8/__LOCALE__ UTF-8/' /etc/locale.gen
   locale-gen __LOCALE__ 
   update-locale LANG=__LOCALE__
fi

# Set keymap
if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then
   /usr/lib/raspberrypi-sys-mods/imager_custom set_keymap '__KEYMAP__'
fi

__WIFI_BLOCK__

# Clean up - remove firstrun.sh and systemd.run from cmdline.txt
rm -f /boot/firstrun.sh /boot/firmware/firstrun.sh
sed -i 's| systemd.run.*||g' /boot/cmdline.txt
sed -i 's| systemd.run.*||g' /boot/firmware/cmdline.txt
exit 0
FIRSTRUN_EOF

    # Replace placeholders in firstrun.sh
    sed -i.bak "s|__HOSTNAME__|$hostname|g" "$boot_volume/firstrun.sh"
    sed -i.bak "s|__USER__|$user|g" "$boot_volume/firstrun.sh"
    sed -i.bak "s|__ENCRYPTED_PASS__|$encrypted_pass|g" "$boot_volume/firstrun.sh"
    sed -i.bak "s|__TIMEZONE__|$timezone|g" "$boot_volume/firstrun.sh"
    sed -i.bak "s|__LOCALE__|$locale|g" "$boot_volume/firstrun.sh"
    sed -i.bak "s|__KEYMAP__|$keymap|g" "$boot_volume/firstrun.sh"
    
    # Add SSH keys block if available
    if [[ -n "$ssh_keys" ]]; then
        # Build enable_ssh command with keys as arguments (match rpi-imager approach)
        # Format: enable_ssh -k 'key1' 'key2' 'key3'
        local ssh_keys_args=""
        while IFS= read -r key_line; do
            [[ -z "$key_line" ]] && continue
            # Escape single quotes in the key for shell safety
            local escaped_key="${key_line//\'/\'\\\'\'}"
            ssh_keys_args+=" '$escaped_key'"
        done <<< "$ssh_keys"
        
        local ssh_block="# Enable SSH and configure keys\n"
        ssh_block+="if [ -f /usr/lib/raspberrypi-sys-mods/imager_custom ]; then\n"
        ssh_block+="   /usr/lib/raspberrypi-sys-mods/imager_custom enable_ssh -k$ssh_keys_args\n"
        ssh_block+="else\n"
        ssh_block+="   systemctl enable ssh\n"
        ssh_block+="   install -o \"\$FIRSTUSER\" -m 700 -d \"\$FIRSTUSERHOME/.ssh\"\n"
        ssh_block+="   cat > \"\$FIRSTUSERHOME/.ssh/authorized_keys\" <<'SSHKEYS_EOF'\n"
        ssh_block+="$ssh_keys\n"
        ssh_block+="SSHKEYS_EOF\n"
        ssh_block+="   chown \"\$FIRSTUSER:\$FIRSTUSER\" \"\$FIRSTUSERHOME/.ssh/authorized_keys\"\n"
        ssh_block+="   chmod 600 \"\$FIRSTUSERHOME/.ssh/authorized_keys\"\n"
        ssh_block+="   echo 'PasswordAuthentication no' >>/etc/ssh/sshd_config\n"
        ssh_block+="   systemctl enable ssh\n"
        ssh_block+="fi"
        # Escape $ signs for perl replacement (same as wifi_block)
        local ssh_block_escaped="${ssh_block//\$/\\\$}"
        perl -i.bak -pe "s|__SSH_KEYS_BLOCK__|$ssh_block_escaped|g" "$boot_volume/firstrun.sh"
    else
        # No SSH keys, just enable SSH with password auth
        local ssh_block="# Enable SSH (password auth only)\n"
        ssh_block+="systemctl enable ssh"
        # Escape $ signs for perl replacement
        local ssh_block_escaped="${ssh_block//\$/\\\$}"
        perl -i.bak -pe "s|__SSH_KEYS_BLOCK__|$ssh_block_escaped|g" "$boot_volume/firstrun.sh"
    fi
    
    rm -f "$boot_volume/firstrun.sh.bak"
    chmod +x "$boot_volume/firstrun.sh"
    log_success "First-boot script created"
    
    # Now apply WiFi configuration if prepared
    if [[ -n "$wifi_block" ]]; then
        log_info "Adding WiFi configuration to firstrun.sh..."
        #sed -i.bak "s|__WIFI_BLOCK__|$wifi_block|g" "$boot_volume/firstrun.sh"
        wifi_block_escaped="${wifi_block//\$/\\\$}"
        perl -i.bak -pe "s|__WIFI_BLOCK__|$wifi_block_escaped|g" "$boot_volume/firstrun.sh"
        rm -f "$boot_volume/firstrun.sh.bak"
        log_success "WiFi configuration added to firstrun.sh"
    else
        # Remove WiFi block placeholder
        #sed -i.bak "s|__WIFI_BLOCK__||g" "$boot_volume/firstrun.sh"
        perl -i.bak -pe "s|__WIFI_BLOCK__||g" "$boot_volume/firstrun.sh"
        rm -f "$boot_volume/firstrun.sh.bak"
    fi
    
    # CRITICAL: Modify cmdline.txt to trigger firstrun.sh execution
    log_info "Modifying cmdline.txt to trigger firstrun.sh..."
    if [[ -f "$boot_volume/cmdline.txt" ]]; then
        # Backup original
        cp "$boot_volume/cmdline.txt" "$boot_volume/cmdline.txt.bak"
        
        # Add systemd.run parameters to trigger firstrun.sh
        # Remove any existing systemd.run parameters first
        sed -i.tmp 's| systemd.run.*||g' "$boot_volume/cmdline.txt"
        # Add new parameters at the end
        sed -i.tmp 's/$/ systemd.run=\/boot\/firstrun.sh systemd.run_success_action=reboot systemd.unit=kernel-command-line.target/' "$boot_volume/cmdline.txt"
        rm -f "$boot_volume/cmdline.txt.tmp"
        log_success "cmdline.txt modified to trigger firstrun.sh"
    else
        log_error "cmdline.txt not found in boot partition!"
        exit 1
    fi
    
    # Eject SD card
    log_info "Ejecting SD card..."
    diskutil eject "$sd_card"
    
    log_success "SD card configured and ejected"
}



# Main execution
main() {
    # Check arguments
    if [[ $# -lt 2 ]]; then
        usage
    fi
    
    local image_source="$1"
    local hostname="$2"
    shift 2
    
    # Check for help
    if [[ "$image_source" == "--help" ]] || [[ "$image_source" == "-h" ]]; then
        usage
    fi
    
    # Load defaults from config file
    local defaults_content=""
    if [[ -f "$CONFIG_FILE" ]]; then
        defaults_content=$(grep -A 20 "^defaults:" "$CONFIG_FILE" | tail -n +2 || true)
        if [[ -n "$defaults_content" ]]; then
            export DEFAULTS_CONTENT="$defaults_content"
        fi
    fi
    
    # Try to load preset configuration for this hostname
    local preset_disable_wifi=""
    if preset_content=$(load_host_preset "$hostname" 2>/dev/null); then
        log_info "Found preset configuration for: $hostname"
        preset_disable_wifi=$(get_config_value "$preset_content" "disable_wifi")
        # Store preset for use in configure_boot (will be overridden by CLI options)
        export PRESET_CONTENT="$preset_content"
    fi
    
    # Check dependencies
    check_dependencies
    
    # Handle skip-flash option
    local skip_flash=false
    for arg in "$@"; do
        if [[ "$arg" == "--skip-flash" ]]; then
            skip_flash=true
            break
        fi
    done
    
    if [[ "$skip_flash" == "false" ]]; then
        # Download image
        local img_file=$(download_image "$image_source")
        
        # Find SD card (with confirmation prompt)
        local sd_card=$(find_sd_card false)
        
        # Flash SD card
        flash_sd_card "$img_file" "$sd_card"
    else
        log_info "Skipping flash (--skip-flash specified)"
        # Find SD card (skip confirmation since we're not flashing)
        local sd_card=$(find_sd_card true)
    fi
    
    # Configure boot partition
    configure_boot "$sd_card" "$hostname" "$image_source" "$@"
    
    # Display summary
    echo
    echo "================================================"
    echo "Provisioning Complete!"
    echo "================================================"
    echo
    echo "Next steps:"
    echo "1. Insert the SD card into your Raspberry Pi"
    echo "2. Power on the device"
    echo "3. Wait 2-3 minutes for first boot"
    echo "4. Connect via SSH: ssh ${user:-pi}@${hostname}.local"
    log_success "Provisioning complete!"
}

# Run main function
main "$@"
